## flipping_bits

description：You have two captured ciphertexts. The public key is (e1, n). But,due to a transient bit flip, the second ciphertext was encrypted with a faultypublic key: (e2, n). Recover the plaintexts.

描述：你有两个捕获的密文。 公钥是（e1，n）。 但，由于瞬态位翻转，第二个密文被加密了故障公钥：（e2，n）。 恢复明文。

先假设两次被加密的明文是相同，那我们可以使用共模攻击的方式来还原出明文。

>关于共模攻击：
>
>如果在RSA的使用中使用了相同的模n对相同的明文m进行了加密，那么就可以在不分解n的情况下还原出明文m的值。
>
>$$ c_1 \equiv m^{e_1}\space mod\space n$$
>
>$$ c_2 \equiv m^{e_2}\space mod\space n$$
>
>由题可知，$e_1,e_2$互质：
>
>$$ (e_1,e_2)=1 $$
>即存在$ s_2 $，$ s_2 $使得：
>
>$$ s_1e_1+s_2e_2=1 $$
>又因为：
>$$ c_1\equiv m^{e_1}\space mod\space n$$
>
>$$ c_2\equiv m^{e_2}\space mod\space n$$
>通过代入化简可以得出：
>$$c_1^{s_1} c_2^{s_2}\equiv m\space mod\space n$$

用代码实现：

```python
import gmpy2
import binascii

c1 = 13981765388145083997703333682243956434148306954774120760845671024723583618341148528952063316653588928138430524040717841543528568326674293677228449651281422762216853098529425814740156575513620513245005576508982103360592761380293006244528169193632346512170599896471850340765607466109228426538780591853882736654
c2 = 79459949016924442856959059325390894723232586275925931898929445938338123216278271333902062872565058205136627757713051954083968874644581902371182266588247653857616029881453100387797111559677392017415298580136496204898016797180386402171968931958365160589774450964944023720256848731202333789801071962338635072065
e1 = 13
e2 = 15
n = 103109065902334620226101162008793963504256027939117020091876799039690801944735604259018655534860183205031069083254290258577291605287053538752280231959857465853228851714786887294961873006234153079187216285516823832102424110934062954272346111907571393964363630079343598511602013316604641904852018969178919051627


def egcd(a,b):
    if b==0:
        return a,1,0
    else:
        g,x,y=egcd(b,a%b)
        return g,y,x-a//b*y

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return (x+m) % m
        

s = egcd(e1, e2)
print (s)
s1 = s[1]
s2 = s[2]

if s1<0:
    s1 = - s1
    c1 = modinv(c1, n)
elif s2<0:
    s2 = - s2
    c2 = modinv(c2, n)
m=(pow(c1,s1,n)*pow(c2,s2,n)) % n

m=hex(m).replace('l','').replace('L','').replace('0x','')

print binascii.a2b_hex(m)
```
最后得到flag：

```
flag-54d3db5c1efcd7afa579c37bcb560ae0
```
